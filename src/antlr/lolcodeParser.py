# Generated from /Users/karolinabogacka/PycharmProjects/lol2py/antlr shtuff/lolcode.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3/")
        buf.write("\u013d\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\3\2\3\2\3\2\3\2\5\2C\n\2\3\3\6\3F\n\3\r\3\16")
        buf.write("\3G\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4")
        buf.write("c\n\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6")
        buf.write("\3\6\3\6\5\6s\n\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\5\7\u0083\n\7\3\b\3\b\7\b\u0087\n")
        buf.write("\b\f\b\16\b\u008a\13\b\3\b\7\b\u008d\n\b\f\b\16\b\u0090")
        buf.write("\13\b\3\b\7\b\u0093\n\b\f\b\16\b\u0096\13\b\3\b\5\b\u0099")
        buf.write("\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3")
        buf.write("\t\3\t\3\t\5\t\u00aa\n\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3")
        buf.write("\n\3\n\3\n\3\n\3\n\5\n\u00b8\n\n\3\13\3\13\3\13\3\f\3")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\7\f\u00c4\n\f\f\f\16\f\u00c7\13")
        buf.write("\f\5\f\u00c9\n\f\3\f\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\16")
        buf.write("\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\5\17\u00e7\n")
        buf.write("\17\3\20\3\20\3\20\3\20\3\21\3\21\3\21\3\21\3\22\3\22")
        buf.write("\3\22\3\22\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3\25")
        buf.write("\3\25\3\25\3\25\3\26\3\26\3\26\3\26\3\27\3\27\3\27\3\27")
        buf.write("\3\30\3\30\3\30\3\30\3\31\3\31\3\31\3\31\3\32\3\32\3\32")
        buf.write("\3\32\3\33\3\33\3\33\3\33\7\33\u0119\n\33\f\33\16\33\u011c")
        buf.write("\13\33\3\33\3\33\3\34\3\34\3\34\3\34\7\34\u0124\n\34\f")
        buf.write("\34\16\34\u0127\13\34\3\34\3\34\3\35\3\35\3\35\3\36\3")
        buf.write("\36\3\36\3\36\3\36\7\36\u0133\n\36\f\36\16\36\u0136\13")
        buf.write("\36\3\36\3\36\3\37\3\37\3\37\3\37\2\2 \2\4\6\b\n\f\16")
        buf.write("\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<\2\2\2")
        buf.write("\u0148\2>\3\2\2\2\4E\3\2\2\2\6b\3\2\2\2\bd\3\2\2\2\nr")
        buf.write("\3\2\2\2\f\u0082\3\2\2\2\16\u0084\3\2\2\2\20\u00a9\3\2")
        buf.write("\2\2\22\u00b7\3\2\2\2\24\u00b9\3\2\2\2\26\u00bc\3\2\2")
        buf.write("\2\30\u00ce\3\2\2\2\32\u00d2\3\2\2\2\34\u00e6\3\2\2\2")
        buf.write("\36\u00e8\3\2\2\2 \u00ec\3\2\2\2\"\u00f0\3\2\2\2$\u00f4")
        buf.write("\3\2\2\2&\u00f8\3\2\2\2(\u00fc\3\2\2\2*\u0100\3\2\2\2")
        buf.write(",\u0104\3\2\2\2.\u0108\3\2\2\2\60\u010c\3\2\2\2\62\u0110")
        buf.write("\3\2\2\2\64\u0114\3\2\2\2\66\u011f\3\2\2\28\u012a\3\2")
        buf.write("\2\2:\u012d\3\2\2\2<\u0139\3\2\2\2>?\7\3\2\2?@\7/\2\2")
        buf.write("@B\5\4\3\2AC\7\4\2\2BA\3\2\2\2BC\3\2\2\2C\3\3\2\2\2DF")
        buf.write("\5\6\4\2ED\3\2\2\2FG\3\2\2\2GE\3\2\2\2GH\3\2\2\2H\5\3")
        buf.write("\2\2\2IJ\5\b\5\2JK\7/\2\2Kc\3\2\2\2LM\5\n\6\2MN\7/\2\2")
        buf.write("Nc\3\2\2\2OP\5\f\7\2PQ\7/\2\2Qc\3\2\2\2RS\5\16\b\2ST\7")
        buf.write("/\2\2Tc\3\2\2\2UV\5\20\t\2VW\7/\2\2Wc\3\2\2\2XY\5\24\13")
        buf.write("\2YZ\7/\2\2Zc\3\2\2\2[\\\5\26\f\2\\]\7/\2\2]c\3\2\2\2")
        buf.write("^_\5\30\r\2_`\7/\2\2`c\3\2\2\2ac\5\32\16\2bI\3\2\2\2b")
        buf.write("L\3\2\2\2bO\3\2\2\2bR\3\2\2\2bU\3\2\2\2bX\3\2\2\2b[\3")
        buf.write("\2\2\2b^\3\2\2\2ba\3\2\2\2c\7\3\2\2\2de\7\5\2\2ef\7+\2")
        buf.write("\2fg\7\6\2\2gh\5\32\16\2hi\5\4\3\2ij\7\7\2\2jk\7+\2\2")
        buf.write("k\t\3\2\2\2lm\7\b\2\2ms\7+\2\2no\7\b\2\2op\7+\2\2pq\7")
        buf.write("\t\2\2qs\7*\2\2rl\3\2\2\2rn\3\2\2\2s\13\3\2\2\2tu\7\n")
        buf.write("\2\2u\u0083\5\34\17\2vw\7\13\2\2wx\7/\2\2xy\5\32\16\2")
        buf.write("yz\7\f\2\2z\u0083\3\2\2\2{|\7\n\2\2|\u0083\7-\2\2}~\7")
        buf.write("\13\2\2~\177\7/\2\2\177\u0080\7-\2\2\u0080\u0081\7/\2")
        buf.write("\2\u0081\u0083\7\f\2\2\u0082t\3\2\2\2\u0082v\3\2\2\2\u0082")
        buf.write("{\3\2\2\2\u0082}\3\2\2\2\u0083\r\3\2\2\2\u0084\u0088\7")
        buf.write("\r\2\2\u0085\u0087\7-\2\2\u0086\u0085\3\2\2\2\u0087\u008a")
        buf.write("\3\2\2\2\u0088\u0086\3\2\2\2\u0088\u0089\3\2\2\2\u0089")
        buf.write("\u008e\3\2\2\2\u008a\u0088\3\2\2\2\u008b\u008d\5\34\17")
        buf.write("\2\u008c\u008b\3\2\2\2\u008d\u0090\3\2\2\2\u008e\u008c")
        buf.write("\3\2\2\2\u008e\u008f\3\2\2\2\u008f\u0094\3\2\2\2\u0090")
        buf.write("\u008e\3\2\2\2\u0091\u0093\7-\2\2\u0092\u0091\3\2\2\2")
        buf.write("\u0093\u0096\3\2\2\2\u0094\u0092\3\2\2\2\u0094\u0095\3")
        buf.write("\2\2\2\u0095\u0098\3\2\2\2\u0096\u0094\3\2\2\2\u0097\u0099")
        buf.write("\7\16\2\2\u0098\u0097\3\2\2\2\u0098\u0099\3\2\2\2\u0099")
        buf.write("\17\3\2\2\2\u009a\u009b\7\17\2\2\u009b\u009c\7/\2\2\u009c")
        buf.write("\u009d\7\20\2\2\u009d\u009e\7/\2\2\u009e\u009f\5\4\3\2")
        buf.write("\u009f\u00a0\7\21\2\2\u00a0\u00aa\3\2\2\2\u00a1\u00a2")
        buf.write("\7\17\2\2\u00a2\u00a3\7/\2\2\u00a3\u00a4\7\20\2\2\u00a4")
        buf.write("\u00a5\7/\2\2\u00a5\u00a6\5\4\3\2\u00a6\u00a7\5\22\n\2")
        buf.write("\u00a7\u00a8\7\21\2\2\u00a8\u00aa\3\2\2\2\u00a9\u009a")
        buf.write("\3\2\2\2\u00a9\u00a1\3\2\2\2\u00aa\21\3\2\2\2\u00ab\u00ac")
        buf.write("\7\22\2\2\u00ac\u00ad\5\32\16\2\u00ad\u00ae\5\4\3\2\u00ae")
        buf.write("\u00af\5\22\n\2\u00af\u00b8\3\2\2\2\u00b0\u00b1\7\23\2")
        buf.write("\2\u00b1\u00b2\7/\2\2\u00b2\u00b8\5\4\3\2\u00b3\u00b4")
        buf.write("\7\22\2\2\u00b4\u00b5\5\32\16\2\u00b5\u00b6\5\4\3\2\u00b6")
        buf.write("\u00b8\3\2\2\2\u00b7\u00ab\3\2\2\2\u00b7\u00b0\3\2\2\2")
        buf.write("\u00b7\u00b3\3\2\2\2\u00b8\23\3\2\2\2\u00b9\u00ba\7\24")
        buf.write("\2\2\u00ba\u00bb\7+\2\2\u00bb\25\3\2\2\2\u00bc\u00bd\7")
        buf.write("\25\2\2\u00bd\u00c8\7+\2\2\u00be\u00bf\7\26\2\2\u00bf")
        buf.write("\u00c0\7+\2\2\u00c0\u00c5\3\2\2\2\u00c1\u00c2\7\27\2\2")
        buf.write("\u00c2\u00c4\7+\2\2\u00c3\u00c1\3\2\2\2\u00c4\u00c7\3")
        buf.write("\2\2\2\u00c5\u00c3\3\2\2\2\u00c5\u00c6\3\2\2\2\u00c6\u00c9")
        buf.write("\3\2\2\2\u00c7\u00c5\3\2\2\2\u00c8\u00be\3\2\2\2\u00c8")
        buf.write("\u00c9\3\2\2\2\u00c9\u00ca\3\2\2\2\u00ca\u00cb\7/\2\2")
        buf.write("\u00cb\u00cc\5\4\3\2\u00cc\u00cd\7\30\2\2\u00cd\27\3\2")
        buf.write("\2\2\u00ce\u00cf\7+\2\2\u00cf\u00d0\7\31\2\2\u00d0\u00d1")
        buf.write("\5\34\17\2\u00d1\31\3\2\2\2\u00d2\u00d3\5\34\17\2\u00d3")
        buf.write("\u00d4\7/\2\2\u00d4\33\3\2\2\2\u00d5\u00e7\5\36\20\2\u00d6")
        buf.write("\u00e7\5\"\22\2\u00d7\u00e7\5 \21\2\u00d8\u00e7\5&\24")
        buf.write("\2\u00d9\u00e7\5(\25\2\u00da\u00e7\5*\26\2\u00db\u00e7")
        buf.write("\5,\27\2\u00dc\u00e7\5.\30\2\u00dd\u00e7\5\60\31\2\u00de")
        buf.write("\u00e7\5\62\32\2\u00df\u00e7\5$\23\2\u00e0\u00e7\5\64")
        buf.write("\33\2\u00e1\u00e7\5\66\34\2\u00e2\u00e7\58\35\2\u00e3")
        buf.write("\u00e7\5:\36\2\u00e4\u00e7\7+\2\2\u00e5\u00e7\7*\2\2\u00e6")
        buf.write("\u00d5\3\2\2\2\u00e6\u00d6\3\2\2\2\u00e6\u00d7\3\2\2\2")
        buf.write("\u00e6\u00d8\3\2\2\2\u00e6\u00d9\3\2\2\2\u00e6\u00da\3")
        buf.write("\2\2\2\u00e6\u00db\3\2\2\2\u00e6\u00dc\3\2\2\2\u00e6\u00dd")
        buf.write("\3\2\2\2\u00e6\u00de\3\2\2\2\u00e6\u00df\3\2\2\2\u00e6")
        buf.write("\u00e0\3\2\2\2\u00e6\u00e1\3\2\2\2\u00e6\u00e2\3\2\2\2")
        buf.write("\u00e6\u00e3\3\2\2\2\u00e6\u00e4\3\2\2\2\u00e6\u00e5\3")
        buf.write("\2\2\2\u00e7\35\3\2\2\2\u00e8\u00e9\7\32\2\2\u00e9\u00ea")
        buf.write("\5\34\17\2\u00ea\u00eb\5<\37\2\u00eb\37\3\2\2\2\u00ec")
        buf.write("\u00ed\7\33\2\2\u00ed\u00ee\5\34\17\2\u00ee\u00ef\5<\37")
        buf.write("\2\u00ef!\3\2\2\2\u00f0\u00f1\7\34\2\2\u00f1\u00f2\5\34")
        buf.write("\17\2\u00f2\u00f3\5<\37\2\u00f3#\3\2\2\2\u00f4\u00f5\7")
        buf.write("\35\2\2\u00f5\u00f6\5\34\17\2\u00f6\u00f7\5<\37\2\u00f7")
        buf.write("%\3\2\2\2\u00f8\u00f9\7\36\2\2\u00f9\u00fa\5\34\17\2\u00fa")
        buf.write("\u00fb\5<\37\2\u00fb\'\3\2\2\2\u00fc\u00fd\7\37\2\2\u00fd")
        buf.write("\u00fe\5\34\17\2\u00fe\u00ff\5<\37\2\u00ff)\3\2\2\2\u0100")
        buf.write("\u0101\7 \2\2\u0101\u0102\5\34\17\2\u0102\u0103\5<\37")
        buf.write("\2\u0103+\3\2\2\2\u0104\u0105\7!\2\2\u0105\u0106\5\34")
        buf.write("\17\2\u0106\u0107\5<\37\2\u0107-\3\2\2\2\u0108\u0109\7")
        buf.write("\"\2\2\u0109\u010a\5\34\17\2\u010a\u010b\5<\37\2\u010b")
        buf.write("/\3\2\2\2\u010c\u010d\7#\2\2\u010d\u010e\5\34\17\2\u010e")
        buf.write("\u010f\5<\37\2\u010f\61\3\2\2\2\u0110\u0111\7$\2\2\u0111")
        buf.write("\u0112\5\34\17\2\u0112\u0113\5<\37\2\u0113\63\3\2\2\2")
        buf.write("\u0114\u0115\7%\2\2\u0115\u011a\5\34\17\2\u0116\u0117")
        buf.write("\7&\2\2\u0117\u0119\5\34\17\2\u0118\u0116\3\2\2\2\u0119")
        buf.write("\u011c\3\2\2\2\u011a\u0118\3\2\2\2\u011a\u011b\3\2\2\2")
        buf.write("\u011b\u011d\3\2\2\2\u011c\u011a\3\2\2\2\u011d\u011e\7")
        buf.write("\16\2\2\u011e\65\3\2\2\2\u011f\u0120\7\'\2\2\u0120\u0125")
        buf.write("\5\34\17\2\u0121\u0122\7&\2\2\u0122\u0124\5\34\17\2\u0123")
        buf.write("\u0121\3\2\2\2\u0124\u0127\3\2\2\2\u0125\u0123\3\2\2\2")
        buf.write("\u0125\u0126\3\2\2\2\u0126\u0128\3\2\2\2\u0127\u0125\3")
        buf.write("\2\2\2\u0128\u0129\7\16\2\2\u0129\67\3\2\2\2\u012a\u012b")
        buf.write("\7(\2\2\u012b\u012c\5\34\17\2\u012c9\3\2\2\2\u012d\u012e")
        buf.write("\7)\2\2\u012e\u012f\7+\2\2\u012f\u0134\5\34\17\2\u0130")
        buf.write("\u0131\7&\2\2\u0131\u0133\5\34\17\2\u0132\u0130\3\2\2")
        buf.write("\2\u0133\u0136\3\2\2\2\u0134\u0132\3\2\2\2\u0134\u0135")
        buf.write("\3\2\2\2\u0135\u0137\3\2\2\2\u0136\u0134\3\2\2\2\u0137")
        buf.write("\u0138\7\16\2\2\u0138;\3\2\2\2\u0139\u013a\7&\2\2\u013a")
        buf.write("\u013b\5\34\17\2\u013b=\3\2\2\2\23BGbr\u0082\u0088\u008e")
        buf.write("\u0094\u0098\u00a9\u00b7\u00c5\u00c8\u00e6\u011a\u0125")
        buf.write("\u0134")
        return buf.getvalue()


class lolcodeParser ( Parser ):

    grammarFileName = "lolcode.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'HAI'", "'KTHXBYE'", "'IM IN YR'", "'WILE'", 
                     "'IM OUTTA YR'", "'I HAS A'", "'ITZ'", "'BTW'", "'OBTW'", 
                     "'TLDR'", "'VISIBLE'", "'MKAY?'", "'O RLY?'", "'YA RLY'", 
                     "'OIC'", "'MEBBE'", "'NO WAI'", "'GIMMEH'", "'HOW DUZ I'", 
                     "'YR'", "'AN YR'", "'IF U SAY SO'", "'R'", "'BOTH SAEM'", 
                     "'DIFFRINT'", "'BOTH OF'", "'EITHER OF'", "'BIGGR OF'", 
                     "'SMALLR OF'", "'SUM OF'", "'DIFF OF'", "'PRODUKT OF'", 
                     "'QUOSHUNT OF'", "'MOD OF'", "'ALL OF'", "'AN'", "'ANY OF'", 
                     "'NOT'", "'I IZ'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "' '" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "ATOM", "LABEL", "BOOLEAN", "STRING", "WHITESPACE", 
                      "NEWLINE" ]

    RULE_program = 0
    RULE_code_block = 1
    RULE_statement = 2
    RULE_loop = 3
    RULE_declaration = 4
    RULE_comment = 5
    RULE_print_block = 6
    RULE_if_block = 7
    RULE_else_if_block = 8
    RULE_input_block = 9
    RULE_func_decl = 10
    RULE_assignment = 11
    RULE_full_expression = 12
    RULE_expression = 13
    RULE_equals = 14
    RULE_not_equals = 15
    RULE_both = 16
    RULE_either = 17
    RULE_greater = 18
    RULE_less = 19
    RULE_add = 20
    RULE_sub = 21
    RULE_mul = 22
    RULE_div = 23
    RULE_mod = 24
    RULE_r_all = 25
    RULE_r_any = 26
    RULE_nope = 27
    RULE_func = 28
    RULE_r_an = 29

    ruleNames =  [ "program", "code_block", "statement", "loop", "declaration", 
                   "comment", "print_block", "if_block", "else_if_block", 
                   "input_block", "func_decl", "assignment", "full_expression", 
                   "expression", "equals", "not_equals", "both", "either", 
                   "greater", "less", "add", "sub", "mul", "div", "mod", 
                   "r_all", "r_any", "nope", "func", "r_an" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    ATOM=40
    LABEL=41
    BOOLEAN=42
    STRING=43
    WHITESPACE=44
    NEWLINE=45

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self):
            return self.getToken(lolcodeParser.NEWLINE, 0)

        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = lolcodeParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60
            self.match(lolcodeParser.T__0)
            self.state = 61
            self.match(lolcodeParser.NEWLINE)
            self.state = 62
            self.code_block()
            self.state = 64
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lolcodeParser.T__1:
                self.state = 63
                self.match(lolcodeParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Code_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.StatementContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.StatementContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_code_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCode_block" ):
                listener.enterCode_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCode_block" ):
                listener.exitCode_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCode_block" ):
                return visitor.visitCode_block(self)
            else:
                return visitor.visitChildren(self)




    def code_block(self):

        localctx = lolcodeParser.Code_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_code_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 66
                self.statement()
                self.state = 69 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << lolcodeParser.T__2) | (1 << lolcodeParser.T__5) | (1 << lolcodeParser.T__7) | (1 << lolcodeParser.T__8) | (1 << lolcodeParser.T__10) | (1 << lolcodeParser.T__12) | (1 << lolcodeParser.T__17) | (1 << lolcodeParser.T__18) | (1 << lolcodeParser.T__23) | (1 << lolcodeParser.T__24) | (1 << lolcodeParser.T__25) | (1 << lolcodeParser.T__26) | (1 << lolcodeParser.T__27) | (1 << lolcodeParser.T__28) | (1 << lolcodeParser.T__29) | (1 << lolcodeParser.T__30) | (1 << lolcodeParser.T__31) | (1 << lolcodeParser.T__32) | (1 << lolcodeParser.T__33) | (1 << lolcodeParser.T__34) | (1 << lolcodeParser.T__36) | (1 << lolcodeParser.T__37) | (1 << lolcodeParser.T__38) | (1 << lolcodeParser.ATOM) | (1 << lolcodeParser.LABEL))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loop(self):
            return self.getTypedRuleContext(lolcodeParser.LoopContext,0)


        def NEWLINE(self):
            return self.getToken(lolcodeParser.NEWLINE, 0)

        def declaration(self):
            return self.getTypedRuleContext(lolcodeParser.DeclarationContext,0)


        def comment(self):
            return self.getTypedRuleContext(lolcodeParser.CommentContext,0)


        def print_block(self):
            return self.getTypedRuleContext(lolcodeParser.Print_blockContext,0)


        def if_block(self):
            return self.getTypedRuleContext(lolcodeParser.If_blockContext,0)


        def input_block(self):
            return self.getTypedRuleContext(lolcodeParser.Input_blockContext,0)


        def func_decl(self):
            return self.getTypedRuleContext(lolcodeParser.Func_declContext,0)


        def assignment(self):
            return self.getTypedRuleContext(lolcodeParser.AssignmentContext,0)


        def full_expression(self):
            return self.getTypedRuleContext(lolcodeParser.Full_expressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = lolcodeParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statement)
        try:
            self.state = 96
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 71
                self.loop()
                self.state = 72
                self.match(lolcodeParser.NEWLINE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 74
                self.declaration()
                self.state = 75
                self.match(lolcodeParser.NEWLINE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 77
                self.comment()
                self.state = 78
                self.match(lolcodeParser.NEWLINE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 80
                self.print_block()
                self.state = 81
                self.match(lolcodeParser.NEWLINE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 83
                self.if_block()
                self.state = 84
                self.match(lolcodeParser.NEWLINE)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 86
                self.input_block()
                self.state = 87
                self.match(lolcodeParser.NEWLINE)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 89
                self.func_decl()
                self.state = 90
                self.match(lolcodeParser.NEWLINE)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 92
                self.assignment()
                self.state = 93
                self.match(lolcodeParser.NEWLINE)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 95
                self.full_expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self, i:int=None):
            if i is None:
                return self.getTokens(lolcodeParser.LABEL)
            else:
                return self.getToken(lolcodeParser.LABEL, i)

        def full_expression(self):
            return self.getTypedRuleContext(lolcodeParser.Full_expressionContext,0)


        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_loop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoop" ):
                listener.enterLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoop" ):
                listener.exitLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoop" ):
                return visitor.visitLoop(self)
            else:
                return visitor.visitChildren(self)




    def loop(self):

        localctx = lolcodeParser.LoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_loop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.match(lolcodeParser.T__2)
            self.state = 99
            self.match(lolcodeParser.LABEL)
            self.state = 100
            self.match(lolcodeParser.T__3)
            self.state = 101
            self.full_expression()
            self.state = 102
            self.code_block()
            self.state = 103
            self.match(lolcodeParser.T__4)
            self.state = 104
            self.match(lolcodeParser.LABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def ATOM(self):
            return self.getToken(lolcodeParser.ATOM, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclaration" ):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def declaration(self):

        localctx = lolcodeParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_declaration)
        try:
            self.state = 112
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 106
                self.match(lolcodeParser.T__5)
                self.state = 107
                self.match(lolcodeParser.LABEL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 108
                self.match(lolcodeParser.T__5)
                self.state = 109
                self.match(lolcodeParser.LABEL)
                self.state = 110
                self.match(lolcodeParser.T__6)
                self.state = 111
                self.match(lolcodeParser.ATOM)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(lolcodeParser.NEWLINE)
            else:
                return self.getToken(lolcodeParser.NEWLINE, i)

        def full_expression(self):
            return self.getTypedRuleContext(lolcodeParser.Full_expressionContext,0)


        def STRING(self):
            return self.getToken(lolcodeParser.STRING, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_comment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComment" ):
                listener.enterComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComment" ):
                listener.exitComment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComment" ):
                return visitor.visitComment(self)
            else:
                return visitor.visitChildren(self)




    def comment(self):

        localctx = lolcodeParser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_comment)
        try:
            self.state = 128
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 114
                self.match(lolcodeParser.T__7)
                self.state = 115
                self.expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 116
                self.match(lolcodeParser.T__8)
                self.state = 117
                self.match(lolcodeParser.NEWLINE)
                self.state = 118
                self.full_expression()
                self.state = 119
                self.match(lolcodeParser.T__9)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 121
                self.match(lolcodeParser.T__7)
                self.state = 122
                self.match(lolcodeParser.STRING)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 123
                self.match(lolcodeParser.T__8)
                self.state = 124
                self.match(lolcodeParser.NEWLINE)
                self.state = 125
                self.match(lolcodeParser.STRING)
                self.state = 126
                self.match(lolcodeParser.NEWLINE)
                self.state = 127
                self.match(lolcodeParser.T__9)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Print_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(lolcodeParser.STRING)
            else:
                return self.getToken(lolcodeParser.STRING, i)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_print_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrint_block" ):
                listener.enterPrint_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrint_block" ):
                listener.exitPrint_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrint_block" ):
                return visitor.visitPrint_block(self)
            else:
                return visitor.visitChildren(self)




    def print_block(self):

        localctx = lolcodeParser.Print_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_print_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 130
            self.match(lolcodeParser.T__10)
            self.state = 134
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 131
                    self.match(lolcodeParser.STRING) 
                self.state = 136
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

            self.state = 140
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << lolcodeParser.T__23) | (1 << lolcodeParser.T__24) | (1 << lolcodeParser.T__25) | (1 << lolcodeParser.T__26) | (1 << lolcodeParser.T__27) | (1 << lolcodeParser.T__28) | (1 << lolcodeParser.T__29) | (1 << lolcodeParser.T__30) | (1 << lolcodeParser.T__31) | (1 << lolcodeParser.T__32) | (1 << lolcodeParser.T__33) | (1 << lolcodeParser.T__34) | (1 << lolcodeParser.T__36) | (1 << lolcodeParser.T__37) | (1 << lolcodeParser.T__38) | (1 << lolcodeParser.ATOM) | (1 << lolcodeParser.LABEL))) != 0):
                self.state = 137
                self.expression()
                self.state = 142
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 146
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lolcodeParser.STRING:
                self.state = 143
                self.match(lolcodeParser.STRING)
                self.state = 148
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lolcodeParser.T__11:
                self.state = 149
                self.match(lolcodeParser.T__11)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(lolcodeParser.NEWLINE)
            else:
                return self.getToken(lolcodeParser.NEWLINE, i)

        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def else_if_block(self):
            return self.getTypedRuleContext(lolcodeParser.Else_if_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_if_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_block" ):
                listener.enterIf_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_block" ):
                listener.exitIf_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf_block" ):
                return visitor.visitIf_block(self)
            else:
                return visitor.visitChildren(self)




    def if_block(self):

        localctx = lolcodeParser.If_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_if_block)
        try:
            self.state = 167
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 152
                self.match(lolcodeParser.T__12)
                self.state = 153
                self.match(lolcodeParser.NEWLINE)
                self.state = 154
                self.match(lolcodeParser.T__13)
                self.state = 155
                self.match(lolcodeParser.NEWLINE)
                self.state = 156
                self.code_block()
                self.state = 157
                self.match(lolcodeParser.T__14)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 159
                self.match(lolcodeParser.T__12)
                self.state = 160
                self.match(lolcodeParser.NEWLINE)
                self.state = 161
                self.match(lolcodeParser.T__13)
                self.state = 162
                self.match(lolcodeParser.NEWLINE)
                self.state = 163
                self.code_block()
                self.state = 164
                self.else_if_block()
                self.state = 165
                self.match(lolcodeParser.T__14)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Else_if_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def full_expression(self):
            return self.getTypedRuleContext(lolcodeParser.Full_expressionContext,0)


        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def else_if_block(self):
            return self.getTypedRuleContext(lolcodeParser.Else_if_blockContext,0)


        def NEWLINE(self):
            return self.getToken(lolcodeParser.NEWLINE, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_else_if_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElse_if_block" ):
                listener.enterElse_if_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElse_if_block" ):
                listener.exitElse_if_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElse_if_block" ):
                return visitor.visitElse_if_block(self)
            else:
                return visitor.visitChildren(self)




    def else_if_block(self):

        localctx = lolcodeParser.Else_if_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_else_if_block)
        try:
            self.state = 181
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 169
                self.match(lolcodeParser.T__15)
                self.state = 170
                self.full_expression()
                self.state = 171
                self.code_block()
                self.state = 172
                self.else_if_block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 174
                self.match(lolcodeParser.T__16)
                self.state = 175
                self.match(lolcodeParser.NEWLINE)
                self.state = 176
                self.code_block()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 177
                self.match(lolcodeParser.T__15)
                self.state = 178
                self.full_expression()
                self.state = 179
                self.code_block()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Input_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_input_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInput_block" ):
                listener.enterInput_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInput_block" ):
                listener.exitInput_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInput_block" ):
                return visitor.visitInput_block(self)
            else:
                return visitor.visitChildren(self)




    def input_block(self):

        localctx = lolcodeParser.Input_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_input_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(lolcodeParser.T__17)
            self.state = 184
            self.match(lolcodeParser.LABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Func_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self, i:int=None):
            if i is None:
                return self.getTokens(lolcodeParser.LABEL)
            else:
                return self.getToken(lolcodeParser.LABEL, i)

        def NEWLINE(self):
            return self.getToken(lolcodeParser.NEWLINE, 0)

        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_func_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_decl" ):
                listener.enterFunc_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_decl" ):
                listener.exitFunc_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc_decl" ):
                return visitor.visitFunc_decl(self)
            else:
                return visitor.visitChildren(self)




    def func_decl(self):

        localctx = lolcodeParser.Func_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_func_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(lolcodeParser.T__18)
            self.state = 187
            self.match(lolcodeParser.LABEL)
            self.state = 198
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lolcodeParser.T__19:
                self.state = 188
                self.match(lolcodeParser.T__19)
                self.state = 189
                self.match(lolcodeParser.LABEL)
                self.state = 195
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==lolcodeParser.T__20:
                    self.state = 191
                    self.match(lolcodeParser.T__20)
                    self.state = 192
                    self.match(lolcodeParser.LABEL)
                    self.state = 197
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 200
            self.match(lolcodeParser.NEWLINE)
            self.state = 201
            self.code_block()
            self.state = 202
            self.match(lolcodeParser.T__21)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment" ):
                listener.enterAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment" ):
                listener.exitAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignment" ):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)




    def assignment(self):

        localctx = lolcodeParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 204
            self.match(lolcodeParser.LABEL)
            self.state = 205
            self.match(lolcodeParser.T__22)
            self.state = 206
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Full_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def NEWLINE(self):
            return self.getToken(lolcodeParser.NEWLINE, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_full_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFull_expression" ):
                listener.enterFull_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFull_expression" ):
                listener.exitFull_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFull_expression" ):
                return visitor.visitFull_expression(self)
            else:
                return visitor.visitChildren(self)




    def full_expression(self):

        localctx = lolcodeParser.Full_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_full_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.expression()
            self.state = 209
            self.match(lolcodeParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equals(self):
            return self.getTypedRuleContext(lolcodeParser.EqualsContext,0)


        def both(self):
            return self.getTypedRuleContext(lolcodeParser.BothContext,0)


        def not_equals(self):
            return self.getTypedRuleContext(lolcodeParser.Not_equalsContext,0)


        def greater(self):
            return self.getTypedRuleContext(lolcodeParser.GreaterContext,0)


        def less(self):
            return self.getTypedRuleContext(lolcodeParser.LessContext,0)


        def add(self):
            return self.getTypedRuleContext(lolcodeParser.AddContext,0)


        def sub(self):
            return self.getTypedRuleContext(lolcodeParser.SubContext,0)


        def mul(self):
            return self.getTypedRuleContext(lolcodeParser.MulContext,0)


        def div(self):
            return self.getTypedRuleContext(lolcodeParser.DivContext,0)


        def mod(self):
            return self.getTypedRuleContext(lolcodeParser.ModContext,0)


        def either(self):
            return self.getTypedRuleContext(lolcodeParser.EitherContext,0)


        def r_all(self):
            return self.getTypedRuleContext(lolcodeParser.R_allContext,0)


        def r_any(self):
            return self.getTypedRuleContext(lolcodeParser.R_anyContext,0)


        def nope(self):
            return self.getTypedRuleContext(lolcodeParser.NopeContext,0)


        def func(self):
            return self.getTypedRuleContext(lolcodeParser.FuncContext,0)


        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def ATOM(self):
            return self.getToken(lolcodeParser.ATOM, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = lolcodeParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_expression)
        try:
            self.state = 228
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lolcodeParser.T__23]:
                self.enterOuterAlt(localctx, 1)
                self.state = 211
                self.equals()
                pass
            elif token in [lolcodeParser.T__25]:
                self.enterOuterAlt(localctx, 2)
                self.state = 212
                self.both()
                pass
            elif token in [lolcodeParser.T__24]:
                self.enterOuterAlt(localctx, 3)
                self.state = 213
                self.not_equals()
                pass
            elif token in [lolcodeParser.T__27]:
                self.enterOuterAlt(localctx, 4)
                self.state = 214
                self.greater()
                pass
            elif token in [lolcodeParser.T__28]:
                self.enterOuterAlt(localctx, 5)
                self.state = 215
                self.less()
                pass
            elif token in [lolcodeParser.T__29]:
                self.enterOuterAlt(localctx, 6)
                self.state = 216
                self.add()
                pass
            elif token in [lolcodeParser.T__30]:
                self.enterOuterAlt(localctx, 7)
                self.state = 217
                self.sub()
                pass
            elif token in [lolcodeParser.T__31]:
                self.enterOuterAlt(localctx, 8)
                self.state = 218
                self.mul()
                pass
            elif token in [lolcodeParser.T__32]:
                self.enterOuterAlt(localctx, 9)
                self.state = 219
                self.div()
                pass
            elif token in [lolcodeParser.T__33]:
                self.enterOuterAlt(localctx, 10)
                self.state = 220
                self.mod()
                pass
            elif token in [lolcodeParser.T__26]:
                self.enterOuterAlt(localctx, 11)
                self.state = 221
                self.either()
                pass
            elif token in [lolcodeParser.T__34]:
                self.enterOuterAlt(localctx, 12)
                self.state = 222
                self.r_all()
                pass
            elif token in [lolcodeParser.T__36]:
                self.enterOuterAlt(localctx, 13)
                self.state = 223
                self.r_any()
                pass
            elif token in [lolcodeParser.T__37]:
                self.enterOuterAlt(localctx, 14)
                self.state = 224
                self.nope()
                pass
            elif token in [lolcodeParser.T__38]:
                self.enterOuterAlt(localctx, 15)
                self.state = 225
                self.func()
                pass
            elif token in [lolcodeParser.LABEL]:
                self.enterOuterAlt(localctx, 16)
                self.state = 226
                self.match(lolcodeParser.LABEL)
                pass
            elif token in [lolcodeParser.ATOM]:
                self.enterOuterAlt(localctx, 17)
                self.state = 227
                self.match(lolcodeParser.ATOM)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EqualsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_equals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquals" ):
                listener.enterEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquals" ):
                listener.exitEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEquals" ):
                return visitor.visitEquals(self)
            else:
                return visitor.visitChildren(self)




    def equals(self):

        localctx = lolcodeParser.EqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_equals)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(lolcodeParser.T__23)
            self.state = 231
            self.expression()
            self.state = 232
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Not_equalsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_not_equals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNot_equals" ):
                listener.enterNot_equals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNot_equals" ):
                listener.exitNot_equals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNot_equals" ):
                return visitor.visitNot_equals(self)
            else:
                return visitor.visitChildren(self)




    def not_equals(self):

        localctx = lolcodeParser.Not_equalsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_not_equals)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            self.match(lolcodeParser.T__24)
            self.state = 235
            self.expression()
            self.state = 236
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BothContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_both

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoth" ):
                listener.enterBoth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoth" ):
                listener.exitBoth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoth" ):
                return visitor.visitBoth(self)
            else:
                return visitor.visitChildren(self)




    def both(self):

        localctx = lolcodeParser.BothContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_both)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self.match(lolcodeParser.T__25)
            self.state = 239
            self.expression()
            self.state = 240
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EitherContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_either

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEither" ):
                listener.enterEither(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEither" ):
                listener.exitEither(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEither" ):
                return visitor.visitEither(self)
            else:
                return visitor.visitChildren(self)




    def either(self):

        localctx = lolcodeParser.EitherContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_either)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            self.match(lolcodeParser.T__26)
            self.state = 243
            self.expression()
            self.state = 244
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GreaterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_greater

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGreater" ):
                listener.enterGreater(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGreater" ):
                listener.exitGreater(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGreater" ):
                return visitor.visitGreater(self)
            else:
                return visitor.visitChildren(self)




    def greater(self):

        localctx = lolcodeParser.GreaterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_greater)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 246
            self.match(lolcodeParser.T__27)
            self.state = 247
            self.expression()
            self.state = 248
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LessContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_less

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLess" ):
                listener.enterLess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLess" ):
                listener.exitLess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLess" ):
                return visitor.visitLess(self)
            else:
                return visitor.visitChildren(self)




    def less(self):

        localctx = lolcodeParser.LessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_less)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(lolcodeParser.T__28)
            self.state = 251
            self.expression()
            self.state = 252
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_add

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd" ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd" ):
                listener.exitAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd" ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)




    def add(self):

        localctx = lolcodeParser.AddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_add)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.match(lolcodeParser.T__29)
            self.state = 255
            self.expression()
            self.state = 256
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub" ):
                listener.enterSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub" ):
                listener.exitSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub" ):
                return visitor.visitSub(self)
            else:
                return visitor.visitChildren(self)




    def sub(self):

        localctx = lolcodeParser.SubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_sub)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self.match(lolcodeParser.T__30)
            self.state = 259
            self.expression()
            self.state = 260
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MulContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_mul

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMul" ):
                listener.enterMul(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMul" ):
                listener.exitMul(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMul" ):
                return visitor.visitMul(self)
            else:
                return visitor.visitChildren(self)




    def mul(self):

        localctx = lolcodeParser.MulContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_mul)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.match(lolcodeParser.T__31)
            self.state = 263
            self.expression()
            self.state = 264
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DivContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_div

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiv" ):
                listener.enterDiv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiv" ):
                listener.exitDiv(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDiv" ):
                return visitor.visitDiv(self)
            else:
                return visitor.visitChildren(self)




    def div(self):

        localctx = lolcodeParser.DivContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_div)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.match(lolcodeParser.T__32)
            self.state = 267
            self.expression()
            self.state = 268
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def r_an(self):
            return self.getTypedRuleContext(lolcodeParser.R_anContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_mod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMod" ):
                listener.enterMod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMod" ):
                listener.exitMod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMod" ):
                return visitor.visitMod(self)
            else:
                return visitor.visitChildren(self)




    def mod(self):

        localctx = lolcodeParser.ModContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_mod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            self.match(lolcodeParser.T__33)
            self.state = 271
            self.expression()
            self.state = 272
            self.r_an()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class R_allContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_r_all

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR_all" ):
                listener.enterR_all(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR_all" ):
                listener.exitR_all(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitR_all" ):
                return visitor.visitR_all(self)
            else:
                return visitor.visitChildren(self)




    def r_all(self):

        localctx = lolcodeParser.R_allContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_r_all)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(lolcodeParser.T__34)
            self.state = 275
            self.expression()
            self.state = 280
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lolcodeParser.T__35:
                self.state = 276
                self.match(lolcodeParser.T__35)
                self.state = 277
                self.expression()
                self.state = 282
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 283
            self.match(lolcodeParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class R_anyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_r_any

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR_any" ):
                listener.enterR_any(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR_any" ):
                listener.exitR_any(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitR_any" ):
                return visitor.visitR_any(self)
            else:
                return visitor.visitChildren(self)




    def r_any(self):

        localctx = lolcodeParser.R_anyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_r_any)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self.match(lolcodeParser.T__36)
            self.state = 286
            self.expression()
            self.state = 291
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lolcodeParser.T__35:
                self.state = 287
                self.match(lolcodeParser.T__35)
                self.state = 288
                self.expression()
                self.state = 293
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 294
            self.match(lolcodeParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NopeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_nope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNope" ):
                listener.enterNope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNope" ):
                listener.exitNope(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNope" ):
                return visitor.visitNope(self)
            else:
                return visitor.visitChildren(self)




    def nope(self):

        localctx = lolcodeParser.NopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_nope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.match(lolcodeParser.T__37)
            self.state = 297
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_func

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc" ):
                listener.enterFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc" ):
                listener.exitFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc" ):
                return visitor.visitFunc(self)
            else:
                return visitor.visitChildren(self)




    def func(self):

        localctx = lolcodeParser.FuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_func)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self.match(lolcodeParser.T__38)
            self.state = 300
            self.match(lolcodeParser.LABEL)
            self.state = 301
            self.expression()
            self.state = 306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lolcodeParser.T__35:
                self.state = 302
                self.match(lolcodeParser.T__35)
                self.state = 303
                self.expression()
                self.state = 308
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 309
            self.match(lolcodeParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class R_anContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_r_an

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR_an" ):
                listener.enterR_an(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR_an" ):
                listener.exitR_an(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitR_an" ):
                return visitor.visitR_an(self)
            else:
                return visitor.visitChildren(self)




    def r_an(self):

        localctx = lolcodeParser.R_anContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_r_an)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            self.match(lolcodeParser.T__35)
            self.state = 312
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





