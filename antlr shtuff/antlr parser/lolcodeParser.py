# Generated from /Users/karolinabogacka/PycharmProjects/lol2py/antlr shtuff/lolcode.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3/")
        buf.write("\u0115\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\3\2\3\2\3\2\5\2@\n\2\3\3\6\3C\n\3\r\3\16\3D\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4P\n\4\3\5\3\5\3\5\3\5\3")
        buf.write("\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6\3\6\5\6`\n\6\3\7\3")
        buf.write("\7\3\7\3\7\3\7\5\7g\n\7\3\b\3\b\7\bk\n\b\f\b\16\bn\13")
        buf.write("\b\3\b\5\bq\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3")
        buf.write("\t\3\t\5\t~\n\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3")
        buf.write("\n\3\n\5\n\u008b\n\n\3\13\3\13\3\13\3\f\3\f\3\f\3\f\3")
        buf.write("\f\3\f\3\f\7\f\u0097\n\f\f\f\16\f\u009a\13\f\5\f\u009c")
        buf.write("\n\f\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16\3")
        buf.write("\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\5\16\u00b7\n\16\3\17\3\17\3\17\3\17\3")
        buf.write("\17\3\20\3\20\3\20\3\20\3\20\3\21\3\21\3\21\3\21\3\21")
        buf.write("\3\22\3\22\3\22\3\22\3\22\3\23\3\23\3\23\3\23\3\23\3\24")
        buf.write("\3\24\3\24\3\24\3\24\3\25\3\25\3\25\3\25\3\25\3\26\3\26")
        buf.write("\3\26\3\26\3\26\3\27\3\27\3\27\3\27\3\27\3\30\3\30\3\30")
        buf.write("\3\30\3\30\3\31\3\31\3\31\3\31\3\31\3\32\3\32\3\32\3\32")
        buf.write("\3\33\3\33\3\33\3\33\7\33\u00f8\n\33\f\33\16\33\u00fb")
        buf.write("\13\33\3\33\3\33\3\34\3\34\3\34\3\34\7\34\u0103\n\34\f")
        buf.write("\34\16\34\u0106\13\34\3\34\3\34\3\35\3\35\3\35\3\36\3")
        buf.write("\36\6\36\u010f\n\36\r\36\16\36\u0110\3\36\3\36\3\36\2")
        buf.write("\2\37\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.")
        buf.write("\60\62\64\668:\2\2\2\u011e\2<\3\2\2\2\4B\3\2\2\2\6O\3")
        buf.write("\2\2\2\bQ\3\2\2\2\n_\3\2\2\2\ff\3\2\2\2\16h\3\2\2\2\20")
        buf.write("}\3\2\2\2\22\u008a\3\2\2\2\24\u008c\3\2\2\2\26\u008f\3")
        buf.write("\2\2\2\30\u00a0\3\2\2\2\32\u00b6\3\2\2\2\34\u00b8\3\2")
        buf.write("\2\2\36\u00bd\3\2\2\2 \u00c2\3\2\2\2\"\u00c7\3\2\2\2$")
        buf.write("\u00cc\3\2\2\2&\u00d1\3\2\2\2(\u00d6\3\2\2\2*\u00db\3")
        buf.write("\2\2\2,\u00e0\3\2\2\2.\u00e5\3\2\2\2\60\u00ea\3\2\2\2")
        buf.write("\62\u00ef\3\2\2\2\64\u00f3\3\2\2\2\66\u00fe\3\2\2\28\u0109")
        buf.write("\3\2\2\2:\u010c\3\2\2\2<=\7\3\2\2=?\5\4\3\2>@\7\4\2\2")
        buf.write("?>\3\2\2\2?@\3\2\2\2@\3\3\2\2\2AC\5\6\4\2BA\3\2\2\2CD")
        buf.write("\3\2\2\2DB\3\2\2\2DE\3\2\2\2E\5\3\2\2\2FP\5\b\5\2GP\5")
        buf.write("\n\6\2HP\5\f\7\2IP\5\16\b\2JP\5\20\t\2KP\5\24\13\2LP\5")
        buf.write("\26\f\2MP\5\30\r\2NP\5\32\16\2OF\3\2\2\2OG\3\2\2\2OH\3")
        buf.write("\2\2\2OI\3\2\2\2OJ\3\2\2\2OK\3\2\2\2OL\3\2\2\2OM\3\2\2")
        buf.write("\2ON\3\2\2\2P\7\3\2\2\2QR\7\5\2\2RS\7+\2\2ST\7\6\2\2T")
        buf.write("U\5\32\16\2UV\5\4\3\2VW\7\7\2\2WX\7+\2\2X\t\3\2\2\2YZ")
        buf.write("\7\b\2\2Z`\7+\2\2[\\\7\b\2\2\\]\7+\2\2]^\7\t\2\2^`\7,")
        buf.write("\2\2_Y\3\2\2\2_[\3\2\2\2`\13\3\2\2\2ab\7\n\2\2bg\7.\2")
        buf.write("\2cd\7\13\2\2de\7.\2\2eg\7\f\2\2fa\3\2\2\2fc\3\2\2\2g")
        buf.write("\r\3\2\2\2hl\7\r\2\2ik\5\32\16\2ji\3\2\2\2kn\3\2\2\2l")
        buf.write("j\3\2\2\2lm\3\2\2\2mp\3\2\2\2nl\3\2\2\2oq\7\16\2\2po\3")
        buf.write("\2\2\2pq\3\2\2\2q\17\3\2\2\2rs\7\17\2\2st\7\20\2\2tu\5")
        buf.write("\4\3\2uv\7\21\2\2v~\3\2\2\2wx\7\17\2\2xy\7\20\2\2yz\5")
        buf.write("\4\3\2z{\5\22\n\2{|\7\21\2\2|~\3\2\2\2}r\3\2\2\2}w\3\2")
        buf.write("\2\2~\21\3\2\2\2\177\u0080\7\22\2\2\u0080\u0081\5\32\16")
        buf.write("\2\u0081\u0082\5\4\3\2\u0082\u0083\5\22\n\2\u0083\u008b")
        buf.write("\3\2\2\2\u0084\u0085\7\23\2\2\u0085\u008b\5\4\3\2\u0086")
        buf.write("\u0087\7\22\2\2\u0087\u0088\5\32\16\2\u0088\u0089\5\4")
        buf.write("\3\2\u0089\u008b\3\2\2\2\u008a\177\3\2\2\2\u008a\u0084")
        buf.write("\3\2\2\2\u008a\u0086\3\2\2\2\u008b\23\3\2\2\2\u008c\u008d")
        buf.write("\7\24\2\2\u008d\u008e\7+\2\2\u008e\25\3\2\2\2\u008f\u0090")
        buf.write("\7\25\2\2\u0090\u009b\7+\2\2\u0091\u0092\7\26\2\2\u0092")
        buf.write("\u0093\7+\2\2\u0093\u0098\3\2\2\2\u0094\u0095\7\27\2\2")
        buf.write("\u0095\u0097\7+\2\2\u0096\u0094\3\2\2\2\u0097\u009a\3")
        buf.write("\2\2\2\u0098\u0096\3\2\2\2\u0098\u0099\3\2\2\2\u0099\u009c")
        buf.write("\3\2\2\2\u009a\u0098\3\2\2\2\u009b\u0091\3\2\2\2\u009b")
        buf.write("\u009c\3\2\2\2\u009c\u009d\3\2\2\2\u009d\u009e\5\4\3\2")
        buf.write("\u009e\u009f\7\30\2\2\u009f\27\3\2\2\2\u00a0\u00a1\7+")
        buf.write("\2\2\u00a1\u00a2\7\31\2\2\u00a2\u00a3\5\32\16\2\u00a3")
        buf.write("\31\3\2\2\2\u00a4\u00b7\5\34\17\2\u00a5\u00b7\5 \21\2")
        buf.write("\u00a6\u00b7\5\36\20\2\u00a7\u00b7\5$\23\2\u00a8\u00b7")
        buf.write("\5&\24\2\u00a9\u00b7\5(\25\2\u00aa\u00b7\5*\26\2\u00ab")
        buf.write("\u00b7\5,\27\2\u00ac\u00b7\5.\30\2\u00ad\u00b7\5\60\31")
        buf.write("\2\u00ae\u00b7\5\62\32\2\u00af\u00b7\5\"\22\2\u00b0\u00b7")
        buf.write("\5\64\33\2\u00b1\u00b7\5\66\34\2\u00b2\u00b7\58\35\2\u00b3")
        buf.write("\u00b7\5:\36\2\u00b4\u00b7\7+\2\2\u00b5\u00b7\7,\2\2\u00b6")
        buf.write("\u00a4\3\2\2\2\u00b6\u00a5\3\2\2\2\u00b6\u00a6\3\2\2\2")
        buf.write("\u00b6\u00a7\3\2\2\2\u00b6\u00a8\3\2\2\2\u00b6\u00a9\3")
        buf.write("\2\2\2\u00b6\u00aa\3\2\2\2\u00b6\u00ab\3\2\2\2\u00b6\u00ac")
        buf.write("\3\2\2\2\u00b6\u00ad\3\2\2\2\u00b6\u00ae\3\2\2\2\u00b6")
        buf.write("\u00af\3\2\2\2\u00b6\u00b0\3\2\2\2\u00b6\u00b1\3\2\2\2")
        buf.write("\u00b6\u00b2\3\2\2\2\u00b6\u00b3\3\2\2\2\u00b6\u00b4\3")
        buf.write("\2\2\2\u00b6\u00b5\3\2\2\2\u00b7\33\3\2\2\2\u00b8\u00b9")
        buf.write("\7\32\2\2\u00b9\u00ba\5\32\16\2\u00ba\u00bb\7\33\2\2\u00bb")
        buf.write("\u00bc\5\32\16\2\u00bc\35\3\2\2\2\u00bd\u00be\7\34\2\2")
        buf.write("\u00be\u00bf\5\32\16\2\u00bf\u00c0\7\33\2\2\u00c0\u00c1")
        buf.write("\5\32\16\2\u00c1\37\3\2\2\2\u00c2\u00c3\7\35\2\2\u00c3")
        buf.write("\u00c4\5\32\16\2\u00c4\u00c5\7\33\2\2\u00c5\u00c6\5\32")
        buf.write("\16\2\u00c6!\3\2\2\2\u00c7\u00c8\7\36\2\2\u00c8\u00c9")
        buf.write("\5\32\16\2\u00c9\u00ca\7\33\2\2\u00ca\u00cb\5\32\16\2")
        buf.write("\u00cb#\3\2\2\2\u00cc\u00cd\7\37\2\2\u00cd\u00ce\5\32")
        buf.write("\16\2\u00ce\u00cf\7\33\2\2\u00cf\u00d0\5\32\16\2\u00d0")
        buf.write("%\3\2\2\2\u00d1\u00d2\7 \2\2\u00d2\u00d3\5\32\16\2\u00d3")
        buf.write("\u00d4\7\33\2\2\u00d4\u00d5\5\32\16\2\u00d5\'\3\2\2\2")
        buf.write("\u00d6\u00d7\7!\2\2\u00d7\u00d8\5\32\16\2\u00d8\u00d9")
        buf.write("\7\33\2\2\u00d9\u00da\5\32\16\2\u00da)\3\2\2\2\u00db\u00dc")
        buf.write("\7\"\2\2\u00dc\u00dd\5\32\16\2\u00dd\u00de\7\33\2\2\u00de")
        buf.write("\u00df\5\32\16\2\u00df+\3\2\2\2\u00e0\u00e1\7#\2\2\u00e1")
        buf.write("\u00e2\5\32\16\2\u00e2\u00e3\7\33\2\2\u00e3\u00e4\5\32")
        buf.write("\16\2\u00e4-\3\2\2\2\u00e5\u00e6\7$\2\2\u00e6\u00e7\5")
        buf.write("\32\16\2\u00e7\u00e8\7\33\2\2\u00e8\u00e9\5\32\16\2\u00e9")
        buf.write("/\3\2\2\2\u00ea\u00eb\7%\2\2\u00eb\u00ec\5\32\16\2\u00ec")
        buf.write("\u00ed\7\33\2\2\u00ed\u00ee\5\32\16\2\u00ee\61\3\2\2\2")
        buf.write("\u00ef\u00f0\7&\2\2\u00f0\u00f1\5\32\16\2\u00f1\u00f2")
        buf.write("\7\'\2\2\u00f2\63\3\2\2\2\u00f3\u00f4\7(\2\2\u00f4\u00f9")
        buf.write("\5\32\16\2\u00f5\u00f6\7\33\2\2\u00f6\u00f8\5\32\16\2")
        buf.write("\u00f7\u00f5\3\2\2\2\u00f8\u00fb\3\2\2\2\u00f9\u00f7\3")
        buf.write("\2\2\2\u00f9\u00fa\3\2\2\2\u00fa\u00fc\3\2\2\2\u00fb\u00f9")
        buf.write("\3\2\2\2\u00fc\u00fd\7\16\2\2\u00fd\65\3\2\2\2\u00fe\u00ff")
        buf.write("\7)\2\2\u00ff\u0104\5\32\16\2\u0100\u0101\7\33\2\2\u0101")
        buf.write("\u0103\5\32\16\2\u0102\u0100\3\2\2\2\u0103\u0106\3\2\2")
        buf.write("\2\u0104\u0102\3\2\2\2\u0104\u0105\3\2\2\2\u0105\u0107")
        buf.write("\3\2\2\2\u0106\u0104\3\2\2\2\u0107\u0108\7\16\2\2\u0108")
        buf.write("\67\3\2\2\2\u0109\u010a\7*\2\2\u010a\u010b\5\32\16\2\u010b")
        buf.write("9\3\2\2\2\u010c\u010e\7+\2\2\u010d\u010f\5\32\16\2\u010e")
        buf.write("\u010d\3\2\2\2\u010f\u0110\3\2\2\2\u0110\u010e\3\2\2\2")
        buf.write("\u0110\u0111\3\2\2\2\u0111\u0112\3\2\2\2\u0112\u0113\7")
        buf.write("\16\2\2\u0113;\3\2\2\2\21?DO_flp}\u008a\u0098\u009b\u00b6")
        buf.write("\u00f9\u0104\u0110")
        return buf.getvalue()


class lolcodeParser ( Parser ):

    grammarFileName = "lolcode.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'HAI'", "'KTHXBYE'", "'IM IN YR'", "'WILE'", 
                     "'IM OUTTA YR'", "'I HAS A'", "'ITZ'", "'BTW'", "'OBTW'", 
                     "'TLDR'", "'VISIBLE'", "'MKAY?'", "'O RLY?'", "'YA RLY'", 
                     "'OIC'", "'MEBBE'", "'NO WAI'", "'GIMMEH'", "'HOW DUZ I'", 
                     "'YR'", "'AN YR'", "'IF U SAY SO'", "'R'", "'BOTH SAEM'", 
                     "'AN'", "'DIFFRINT'", "'BOTH OF'", "'EITHER OF'", "'BIGGR OF'", 
                     "'SMALLR OF'", "'SUM OF'", "'DIFF OF'", "'PRODUKT OF'", 
                     "'QUOSHUNT OF'", "'MOD OF'", "'MAEK'", "'A'", "'ALL OF'", 
                     "'ANY OF'", "'NOT'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "LABEL", "ATOM", "BOOLEAN", "STRING", 
                      "WS" ]

    RULE_program = 0
    RULE_code_block = 1
    RULE_statement = 2
    RULE_loop = 3
    RULE_declaration = 4
    RULE_comment = 5
    RULE_print_block = 6
    RULE_if_block = 7
    RULE_else_if_block = 8
    RULE_input_block = 9
    RULE_func_decl = 10
    RULE_assignment = 11
    RULE_expression = 12
    RULE_equals = 13
    RULE_not_equals = 14
    RULE_both = 15
    RULE_either = 16
    RULE_greater = 17
    RULE_less = 18
    RULE_add = 19
    RULE_sub = 20
    RULE_mul = 21
    RULE_div = 22
    RULE_mod = 23
    RULE_cast = 24
    RULE_r_all = 25
    RULE_r_any = 26
    RULE_nope = 27
    RULE_func = 28

    ruleNames =  [ "program", "code_block", "statement", "loop", "declaration", 
                   "comment", "print_block", "if_block", "else_if_block", 
                   "input_block", "func_decl", "assignment", "expression", 
                   "equals", "not_equals", "both", "either", "greater", 
                   "less", "add", "sub", "mul", "div", "mod", "cast", "r_all", 
                   "r_any", "nope", "func" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    LABEL=41
    ATOM=42
    BOOLEAN=43
    STRING=44
    WS=45

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = lolcodeParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self.match(lolcodeParser.T__0)
            self.state = 59
            self.code_block()
            self.state = 61
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lolcodeParser.T__1:
                self.state = 60
                self.match(lolcodeParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Code_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.StatementContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.StatementContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_code_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCode_block" ):
                listener.enterCode_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCode_block" ):
                listener.exitCode_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCode_block" ):
                return visitor.visitCode_block(self)
            else:
                return visitor.visitChildren(self)




    def code_block(self):

        localctx = lolcodeParser.Code_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_code_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 64 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 63
                self.statement()
                self.state = 66 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << lolcodeParser.T__2) | (1 << lolcodeParser.T__5) | (1 << lolcodeParser.T__7) | (1 << lolcodeParser.T__8) | (1 << lolcodeParser.T__10) | (1 << lolcodeParser.T__12) | (1 << lolcodeParser.T__17) | (1 << lolcodeParser.T__18) | (1 << lolcodeParser.T__23) | (1 << lolcodeParser.T__25) | (1 << lolcodeParser.T__26) | (1 << lolcodeParser.T__27) | (1 << lolcodeParser.T__28) | (1 << lolcodeParser.T__29) | (1 << lolcodeParser.T__30) | (1 << lolcodeParser.T__31) | (1 << lolcodeParser.T__32) | (1 << lolcodeParser.T__33) | (1 << lolcodeParser.T__34) | (1 << lolcodeParser.T__35) | (1 << lolcodeParser.T__37) | (1 << lolcodeParser.T__38) | (1 << lolcodeParser.T__39) | (1 << lolcodeParser.LABEL) | (1 << lolcodeParser.ATOM))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loop(self):
            return self.getTypedRuleContext(lolcodeParser.LoopContext,0)


        def declaration(self):
            return self.getTypedRuleContext(lolcodeParser.DeclarationContext,0)


        def comment(self):
            return self.getTypedRuleContext(lolcodeParser.CommentContext,0)


        def print_block(self):
            return self.getTypedRuleContext(lolcodeParser.Print_blockContext,0)


        def if_block(self):
            return self.getTypedRuleContext(lolcodeParser.If_blockContext,0)


        def input_block(self):
            return self.getTypedRuleContext(lolcodeParser.Input_blockContext,0)


        def func_decl(self):
            return self.getTypedRuleContext(lolcodeParser.Func_declContext,0)


        def assignment(self):
            return self.getTypedRuleContext(lolcodeParser.AssignmentContext,0)


        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = lolcodeParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statement)
        try:
            self.state = 77
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 68
                self.loop()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 69
                self.declaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 70
                self.comment()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 71
                self.print_block()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 72
                self.if_block()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 73
                self.input_block()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 74
                self.func_decl()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 75
                self.assignment()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 76
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self, i:int=None):
            if i is None:
                return self.getTokens(lolcodeParser.LABEL)
            else:
                return self.getToken(lolcodeParser.LABEL, i)

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_loop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoop" ):
                listener.enterLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoop" ):
                listener.exitLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoop" ):
                return visitor.visitLoop(self)
            else:
                return visitor.visitChildren(self)




    def loop(self):

        localctx = lolcodeParser.LoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_loop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.match(lolcodeParser.T__2)
            self.state = 80
            self.match(lolcodeParser.LABEL)
            self.state = 81
            self.match(lolcodeParser.T__3)
            self.state = 82
            self.expression()
            self.state = 83
            self.code_block()
            self.state = 84
            self.match(lolcodeParser.T__4)
            self.state = 85
            self.match(lolcodeParser.LABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def ATOM(self):
            return self.getToken(lolcodeParser.ATOM, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclaration" ):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def declaration(self):

        localctx = lolcodeParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_declaration)
        try:
            self.state = 93
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 87
                self.match(lolcodeParser.T__5)
                self.state = 88
                self.match(lolcodeParser.LABEL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 89
                self.match(lolcodeParser.T__5)
                self.state = 90
                self.match(lolcodeParser.LABEL)
                self.state = 91
                self.match(lolcodeParser.T__6)
                self.state = 92
                self.match(lolcodeParser.ATOM)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(lolcodeParser.STRING, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_comment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComment" ):
                listener.enterComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComment" ):
                listener.exitComment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComment" ):
                return visitor.visitComment(self)
            else:
                return visitor.visitChildren(self)




    def comment(self):

        localctx = lolcodeParser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_comment)
        try:
            self.state = 100
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lolcodeParser.T__7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 95
                self.match(lolcodeParser.T__7)
                self.state = 96
                self.match(lolcodeParser.STRING)
                pass
            elif token in [lolcodeParser.T__8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 97
                self.match(lolcodeParser.T__8)
                self.state = 98
                self.match(lolcodeParser.STRING)
                self.state = 99
                self.match(lolcodeParser.T__9)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Print_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_print_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrint_block" ):
                listener.enterPrint_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrint_block" ):
                listener.exitPrint_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrint_block" ):
                return visitor.visitPrint_block(self)
            else:
                return visitor.visitChildren(self)




    def print_block(self):

        localctx = lolcodeParser.Print_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_print_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.match(lolcodeParser.T__10)
            self.state = 106
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 103
                    self.expression() 
                self.state = 108
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

            self.state = 110
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lolcodeParser.T__11:
                self.state = 109
                self.match(lolcodeParser.T__11)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def else_if_block(self):
            return self.getTypedRuleContext(lolcodeParser.Else_if_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_if_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_block" ):
                listener.enterIf_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_block" ):
                listener.exitIf_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf_block" ):
                return visitor.visitIf_block(self)
            else:
                return visitor.visitChildren(self)




    def if_block(self):

        localctx = lolcodeParser.If_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_if_block)
        try:
            self.state = 123
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 112
                self.match(lolcodeParser.T__12)
                self.state = 113
                self.match(lolcodeParser.T__13)
                self.state = 114
                self.code_block()
                self.state = 115
                self.match(lolcodeParser.T__14)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 117
                self.match(lolcodeParser.T__12)
                self.state = 118
                self.match(lolcodeParser.T__13)
                self.state = 119
                self.code_block()
                self.state = 120
                self.else_if_block()
                self.state = 121
                self.match(lolcodeParser.T__14)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Else_if_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def else_if_block(self):
            return self.getTypedRuleContext(lolcodeParser.Else_if_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_else_if_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElse_if_block" ):
                listener.enterElse_if_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElse_if_block" ):
                listener.exitElse_if_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElse_if_block" ):
                return visitor.visitElse_if_block(self)
            else:
                return visitor.visitChildren(self)




    def else_if_block(self):

        localctx = lolcodeParser.Else_if_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_else_if_block)
        try:
            self.state = 136
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 125
                self.match(lolcodeParser.T__15)
                self.state = 126
                self.expression()
                self.state = 127
                self.code_block()
                self.state = 128
                self.else_if_block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 130
                self.match(lolcodeParser.T__16)
                self.state = 131
                self.code_block()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 132
                self.match(lolcodeParser.T__15)
                self.state = 133
                self.expression()
                self.state = 134
                self.code_block()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Input_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_input_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInput_block" ):
                listener.enterInput_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInput_block" ):
                listener.exitInput_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInput_block" ):
                return visitor.visitInput_block(self)
            else:
                return visitor.visitChildren(self)




    def input_block(self):

        localctx = lolcodeParser.Input_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_input_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self.match(lolcodeParser.T__17)
            self.state = 139
            self.match(lolcodeParser.LABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Func_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self, i:int=None):
            if i is None:
                return self.getTokens(lolcodeParser.LABEL)
            else:
                return self.getToken(lolcodeParser.LABEL, i)

        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_func_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_decl" ):
                listener.enterFunc_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_decl" ):
                listener.exitFunc_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc_decl" ):
                return visitor.visitFunc_decl(self)
            else:
                return visitor.visitChildren(self)




    def func_decl(self):

        localctx = lolcodeParser.Func_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_func_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self.match(lolcodeParser.T__18)
            self.state = 142
            self.match(lolcodeParser.LABEL)
            self.state = 153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lolcodeParser.T__19:
                self.state = 143
                self.match(lolcodeParser.T__19)
                self.state = 144
                self.match(lolcodeParser.LABEL)
                self.state = 150
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==lolcodeParser.T__20:
                    self.state = 146
                    self.match(lolcodeParser.T__20)
                    self.state = 147
                    self.match(lolcodeParser.LABEL)
                    self.state = 152
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 155
            self.code_block()
            self.state = 156
            self.match(lolcodeParser.T__21)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment" ):
                listener.enterAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment" ):
                listener.exitAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignment" ):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)




    def assignment(self):

        localctx = lolcodeParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(lolcodeParser.LABEL)
            self.state = 159
            self.match(lolcodeParser.T__22)
            self.state = 160
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equals(self):
            return self.getTypedRuleContext(lolcodeParser.EqualsContext,0)


        def both(self):
            return self.getTypedRuleContext(lolcodeParser.BothContext,0)


        def not_equals(self):
            return self.getTypedRuleContext(lolcodeParser.Not_equalsContext,0)


        def greater(self):
            return self.getTypedRuleContext(lolcodeParser.GreaterContext,0)


        def less(self):
            return self.getTypedRuleContext(lolcodeParser.LessContext,0)


        def add(self):
            return self.getTypedRuleContext(lolcodeParser.AddContext,0)


        def sub(self):
            return self.getTypedRuleContext(lolcodeParser.SubContext,0)


        def mul(self):
            return self.getTypedRuleContext(lolcodeParser.MulContext,0)


        def div(self):
            return self.getTypedRuleContext(lolcodeParser.DivContext,0)


        def mod(self):
            return self.getTypedRuleContext(lolcodeParser.ModContext,0)


        def cast(self):
            return self.getTypedRuleContext(lolcodeParser.CastContext,0)


        def either(self):
            return self.getTypedRuleContext(lolcodeParser.EitherContext,0)


        def r_all(self):
            return self.getTypedRuleContext(lolcodeParser.R_allContext,0)


        def r_any(self):
            return self.getTypedRuleContext(lolcodeParser.R_anyContext,0)


        def nope(self):
            return self.getTypedRuleContext(lolcodeParser.NopeContext,0)


        def func(self):
            return self.getTypedRuleContext(lolcodeParser.FuncContext,0)


        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def ATOM(self):
            return self.getToken(lolcodeParser.ATOM, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = lolcodeParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_expression)
        try:
            self.state = 180
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 162
                self.equals()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 163
                self.both()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 164
                self.not_equals()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 165
                self.greater()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 166
                self.less()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 167
                self.add()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 168
                self.sub()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 169
                self.mul()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 170
                self.div()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 171
                self.mod()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 172
                self.cast()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 173
                self.either()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 174
                self.r_all()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 175
                self.r_any()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 176
                self.nope()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 177
                self.func()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 178
                self.match(lolcodeParser.LABEL)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 179
                self.match(lolcodeParser.ATOM)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EqualsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_equals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquals" ):
                listener.enterEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquals" ):
                listener.exitEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEquals" ):
                return visitor.visitEquals(self)
            else:
                return visitor.visitChildren(self)




    def equals(self):

        localctx = lolcodeParser.EqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_equals)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(lolcodeParser.T__23)
            self.state = 183
            self.expression()
            self.state = 184
            self.match(lolcodeParser.T__24)
            self.state = 185
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Not_equalsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_not_equals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNot_equals" ):
                listener.enterNot_equals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNot_equals" ):
                listener.exitNot_equals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNot_equals" ):
                return visitor.visitNot_equals(self)
            else:
                return visitor.visitChildren(self)




    def not_equals(self):

        localctx = lolcodeParser.Not_equalsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_not_equals)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            self.match(lolcodeParser.T__25)
            self.state = 188
            self.expression()
            self.state = 189
            self.match(lolcodeParser.T__24)
            self.state = 190
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BothContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_both

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoth" ):
                listener.enterBoth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoth" ):
                listener.exitBoth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoth" ):
                return visitor.visitBoth(self)
            else:
                return visitor.visitChildren(self)




    def both(self):

        localctx = lolcodeParser.BothContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_both)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            self.match(lolcodeParser.T__26)
            self.state = 193
            self.expression()
            self.state = 194
            self.match(lolcodeParser.T__24)
            self.state = 195
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EitherContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_either

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEither" ):
                listener.enterEither(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEither" ):
                listener.exitEither(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEither" ):
                return visitor.visitEither(self)
            else:
                return visitor.visitChildren(self)




    def either(self):

        localctx = lolcodeParser.EitherContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_either)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(lolcodeParser.T__27)
            self.state = 198
            self.expression()
            self.state = 199
            self.match(lolcodeParser.T__24)
            self.state = 200
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GreaterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_greater

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGreater" ):
                listener.enterGreater(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGreater" ):
                listener.exitGreater(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGreater" ):
                return visitor.visitGreater(self)
            else:
                return visitor.visitChildren(self)




    def greater(self):

        localctx = lolcodeParser.GreaterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_greater)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.match(lolcodeParser.T__28)
            self.state = 203
            self.expression()
            self.state = 204
            self.match(lolcodeParser.T__24)
            self.state = 205
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LessContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_less

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLess" ):
                listener.enterLess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLess" ):
                listener.exitLess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLess" ):
                return visitor.visitLess(self)
            else:
                return visitor.visitChildren(self)




    def less(self):

        localctx = lolcodeParser.LessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_less)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 207
            self.match(lolcodeParser.T__29)
            self.state = 208
            self.expression()
            self.state = 209
            self.match(lolcodeParser.T__24)
            self.state = 210
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_add

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd" ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd" ):
                listener.exitAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd" ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)




    def add(self):

        localctx = lolcodeParser.AddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_add)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self.match(lolcodeParser.T__30)
            self.state = 213
            self.expression()
            self.state = 214
            self.match(lolcodeParser.T__24)
            self.state = 215
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub" ):
                listener.enterSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub" ):
                listener.exitSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub" ):
                return visitor.visitSub(self)
            else:
                return visitor.visitChildren(self)




    def sub(self):

        localctx = lolcodeParser.SubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_sub)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 217
            self.match(lolcodeParser.T__31)
            self.state = 218
            self.expression()
            self.state = 219
            self.match(lolcodeParser.T__24)
            self.state = 220
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MulContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_mul

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMul" ):
                listener.enterMul(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMul" ):
                listener.exitMul(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMul" ):
                return visitor.visitMul(self)
            else:
                return visitor.visitChildren(self)




    def mul(self):

        localctx = lolcodeParser.MulContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_mul)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            self.match(lolcodeParser.T__32)
            self.state = 223
            self.expression()
            self.state = 224
            self.match(lolcodeParser.T__24)
            self.state = 225
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DivContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_div

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiv" ):
                listener.enterDiv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiv" ):
                listener.exitDiv(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDiv" ):
                return visitor.visitDiv(self)
            else:
                return visitor.visitChildren(self)




    def div(self):

        localctx = lolcodeParser.DivContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_div)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 227
            self.match(lolcodeParser.T__33)
            self.state = 228
            self.expression()
            self.state = 229
            self.match(lolcodeParser.T__24)
            self.state = 230
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_mod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMod" ):
                listener.enterMod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMod" ):
                listener.exitMod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMod" ):
                return visitor.visitMod(self)
            else:
                return visitor.visitChildren(self)




    def mod(self):

        localctx = lolcodeParser.ModContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_mod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.match(lolcodeParser.T__34)
            self.state = 233
            self.expression()
            self.state = 234
            self.match(lolcodeParser.T__24)
            self.state = 235
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast" ):
                return visitor.visitCast(self)
            else:
                return visitor.visitChildren(self)




    def cast(self):

        localctx = lolcodeParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_cast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 237
            self.match(lolcodeParser.T__35)
            self.state = 238
            self.expression()
            self.state = 239
            self.match(lolcodeParser.T__36)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class R_allContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_r_all

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR_all" ):
                listener.enterR_all(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR_all" ):
                listener.exitR_all(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitR_all" ):
                return visitor.visitR_all(self)
            else:
                return visitor.visitChildren(self)




    def r_all(self):

        localctx = lolcodeParser.R_allContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_r_all)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            self.match(lolcodeParser.T__37)
            self.state = 242
            self.expression()
            self.state = 247
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lolcodeParser.T__24:
                self.state = 243
                self.match(lolcodeParser.T__24)
                self.state = 244
                self.expression()
                self.state = 249
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 250
            self.match(lolcodeParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class R_anyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_r_any

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR_any" ):
                listener.enterR_any(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR_any" ):
                listener.exitR_any(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitR_any" ):
                return visitor.visitR_any(self)
            else:
                return visitor.visitChildren(self)




    def r_any(self):

        localctx = lolcodeParser.R_anyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_r_any)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            self.match(lolcodeParser.T__38)
            self.state = 253
            self.expression()
            self.state = 258
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lolcodeParser.T__24:
                self.state = 254
                self.match(lolcodeParser.T__24)
                self.state = 255
                self.expression()
                self.state = 260
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 261
            self.match(lolcodeParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NopeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_nope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNope" ):
                listener.enterNope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNope" ):
                listener.exitNope(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNope" ):
                return visitor.visitNope(self)
            else:
                return visitor.visitChildren(self)




    def nope(self):

        localctx = lolcodeParser.NopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_nope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            self.match(lolcodeParser.T__39)
            self.state = 264
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_func

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc" ):
                listener.enterFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc" ):
                listener.exitFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc" ):
                return visitor.visitFunc(self)
            else:
                return visitor.visitChildren(self)




    def func(self):

        localctx = lolcodeParser.FuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_func)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.match(lolcodeParser.LABEL)
            self.state = 268 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 267
                self.expression()
                self.state = 270 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << lolcodeParser.T__23) | (1 << lolcodeParser.T__25) | (1 << lolcodeParser.T__26) | (1 << lolcodeParser.T__27) | (1 << lolcodeParser.T__28) | (1 << lolcodeParser.T__29) | (1 << lolcodeParser.T__30) | (1 << lolcodeParser.T__31) | (1 << lolcodeParser.T__32) | (1 << lolcodeParser.T__33) | (1 << lolcodeParser.T__34) | (1 << lolcodeParser.T__35) | (1 << lolcodeParser.T__37) | (1 << lolcodeParser.T__38) | (1 << lolcodeParser.T__39) | (1 << lolcodeParser.LABEL) | (1 << lolcodeParser.ATOM))) != 0)):
                    break

            self.state = 272
            self.match(lolcodeParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





